// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.10;

import {IVariableSupplyAuction} from "./IVariableSupplyAuction.sol";
import {ERC721Drop} from "./temp-ERC721Drop.sol";

import {ReentrancyGuard} from "@rari-capital/solmate/src/utils/ReentrancyGuard.sol";

/// @title Variable Supply Auction
/// @author neodaoist
/// @notice Module for variable supply, seller's choice, sealed bid auctions in ETH for ERC-721 tokens
contract VariableSupplyAuction is IVariableSupplyAuction, ReentrancyGuard {
    //

    /*//////////////////////////////////////////////////////////////
                        AUCTION STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The metadata for a given auction
    /// @param seller The seller of this auction
    /// @param minimumRevenue The minimum revenue the seller needs to generate in this auction
    /// @param sellerFundsRecipient The address where funds are sent after the auction
    /// @param startTime The unix timestamp after which the first bid can be placed
    /// @param endOfBidPhase The unix timestamp until which bids can be placed
    /// @param endOfRevealPhase The unix timestamp until which placed bids can be revealed
    /// @param endOfSettlePhase The unix timestamp until which the seller can settle the auction (TODO clarify can vs. must)
    struct Auction {
        address seller;
        uint96 minimumRevenue;
        address sellerFundsRecipient;
        uint32 startTime;
        uint32 endOfBidPhase;
        uint32 endOfRevealPhase;
        uint32 endOfSettlePhase;
        uint96 totalBalance;
        // mapping(address => mapping(address => uint96)) balanceOf;
        // mapping(address => mapping(address => Bid)) bidOf;
    }

    ///
    struct Bid {
        bytes32 commitment;
        uint96 revealed;
    }

    /// @notice The auction for a given seller, if one exists
    /// @dev Only one auction per seller is allowed at once
    // mapping(address => Auction) public auctionForSeller;
    mapping(address => Auction) public auctionForDrop;

    ///
    mapping(address => mapping(address => uint96)) public balanceOf;

    ///
    mapping(address => mapping(address => Bid)) public bidOf;

    /*//////////////////////////////////////////////////////////////
                        CREATE AUCTION
    //////////////////////////////////////////////////////////////*/

    // TODO add UML diagram

    /// @notice Emitted when an auction is created
    /// @param drop The ERC721Drop contract address of the created auction
    /// @param auction The metadata of the created auction
    event AuctionCreated(address indexed drop, Auction auction);

    /// @notice Creates a variable supply auction
    /// @dev Drop can only have 1 live auction at any one time
    /// @param _tokenContract The address of the ERC721Drop contract
    /// @param _minimumRevenue The minimum revenue the seller aims to generate in this auction --
    /// they can settle the auction below this value, but they cannot _not_ settle if the revenue
    /// generated by any price point + edition size combination would be at least this value
    /// @param _sellerFundsRecipient The address to send funds to once the auction is complete
    /// @param _startTime The time that users can begin placing bids
    /// @param _bidPhaseDuration The length of time of the bid phase in seconds
    /// @param _revealPhaseDuration The length of time of the reveal phase in seconds
    /// @param _settlePhaseDuration The length of time of the settle phase in seconds
    function createAuction(
        address _tokenContract,
        uint256 _minimumRevenue,
        address _sellerFundsRecipient,
        uint256 _startTime,
        uint256 _bidPhaseDuration,
        uint256 _revealPhaseDuration,
        uint256 _settlePhaseDuration
    ) external nonReentrant {
        // Ensure the drop does not already have a live auction
        require(auctionForDrop[_tokenContract].startTime == 0, "ONLY_ONE_LIVE_AUCTION_PER_DROP");

        // Ensure the funds recipient is specified
        require(_sellerFundsRecipient != address(0), "INVALID_FUNDS_RECIPIENT");

        // Get the auction's storage pointer
        Auction storage auction = auctionForDrop[_tokenContract];

        // Store the associated metadata
        auction.seller = msg.sender;
        auction.minimumRevenue = uint96(_minimumRevenue);
        auction.sellerFundsRecipient = _sellerFundsRecipient;
        auction.startTime = uint32(_startTime);
        auction.endOfBidPhase = uint32(_startTime + _bidPhaseDuration);
        auction.endOfRevealPhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration);
        auction.endOfSettlePhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration + _settlePhaseDuration);

        emit AuctionCreated(_tokenContract, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        PLACE BID
    //////////////////////////////////////////////////////////////*/

    // TODO add UML

    /// @notice Emitted when a bid is placed
    /// @param tokenContract The ERC-721 drop token contract of the auction
    /// @param bidder The address that placed a sealed bid
    /// @param auction The metadata of the auction
    event AuctionBid(address indexed tokenContract, address indexed bidder, Auction auction);

    ///
    function placeBid(address _tokenContract, bytes32 _commitment) public payable nonReentrant {
        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // TODO checks

        // Store the full amount of incoming ether for this auction
        auction.totalBalance += uint96(msg.value);
        
        // Store the amount of incoming ether for this bidder
        balanceOf[_tokenContract][msg.sender] = uint96(msg.value);

        // Store the committed / unrevealed bid for this bidder
        bidOf[_tokenContract][msg.sender] = Bid({
            commitment: _commitment,
            revealed: 0
        });

        emit AuctionBid(_tokenContract, msg.sender, auction);
    }
}
