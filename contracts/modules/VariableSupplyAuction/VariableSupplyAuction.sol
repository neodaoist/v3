// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.10;

import {IVariableSupplyAuction} from "./IVariableSupplyAuction.sol";
import {ERC721Drop} from "./temp-ERC721Drop.sol";

import {ReentrancyGuard} from "@rari-capital/solmate/src/utils/ReentrancyGuard.sol";

/// @title Variable Supply Auction
/// @author neodaoist
/// @notice Module for variable supply, seller's choice, sealed bid auctions in ETH for ERC-721 tokens
contract VariableSupplyAuction is IVariableSupplyAuction, ReentrancyGuard {
    //

    /*//////////////////////////////////////////////////////////////
                        AUCTION STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The metadata for a given auction
    /// @param seller The seller of this auction
    /// @param minimumRevenue The minimum revenue the seller needs to generate in this auction
    /// @param sellerFundsRecipient The address where funds are sent after the auction
    /// @param startTime The unix timestamp after which the first bid can be placed
    /// @param endOfBidPhase The unix timestamp until which bids can be placed
    /// @param endOfRevealPhase The unix timestamp until which placed bids can be revealed
    /// @param endOfSettlePhase The unix timestamp until which the seller can settle the auction (TODO clarify can vs. must)
    struct Auction {
        address seller;
        uint96 minimumRevenue;
        address sellerFundsRecipient;
        uint32 startTime;
        uint32 endOfBidPhase;
        uint32 endOfRevealPhase;
        uint32 endOfSettlePhase;
        uint96 totalBalance;
        // mapping(address => mapping(address => uint96)) balanceOf;
        // mapping(address => mapping(address => Bid)) bidOf;
    }

    /// TODO
    struct Bid {
        bytes32 commitmentHash;
        uint96 revealedBidAmount;
    }

    /// @notice The auction for a given seller, if one exists
    /// @dev Only one auction per seller is allowed at once
    // mapping(address => Auction) public auctionForSeller;
    mapping(address => Auction) public auctionForDrop;

    /// TODO
    mapping(address => mapping(address => uint96)) public balanceOf;

    /// TODO
    mapping(address => mapping(address => Bid)) public bidOf;

    /*//////////////////////////////////////////////////////////////
                        CREATE AUCTION
    //////////////////////////////////////////////////////////////*/

    // TODO add UML diagram

    /// @notice Emitted when an auction is created
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param auction The metadata of the created auction
    event AuctionCreated(address indexed tokenContract, Auction auction);

    /// @notice Creates a variable supply auction
    /// @dev A given ERC-721 drop contract can have only one live auction at any one time
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _minimumRevenue The minimum revenue the seller aims to generate in this auction --
    /// they can settle the auction below this value, but they cannot _not_ settle if the revenue
    /// generated by any price point + edition size combination would be at least this value
    /// @param _sellerFundsRecipient The address to send funds to once the auction is complete
    /// @param _startTime The time that users can begin placing bids
    /// @param _bidPhaseDuration The length of time of the bid phase in seconds
    /// @param _revealPhaseDuration The length of time of the reveal phase in seconds
    /// @param _settlePhaseDuration The length of time of the settle phase in seconds
    function createAuction(
        address _tokenContract,
        uint256 _minimumRevenue,
        address _sellerFundsRecipient,
        uint256 _startTime,
        uint256 _bidPhaseDuration,
        uint256 _revealPhaseDuration,
        uint256 _settlePhaseDuration
    ) external nonReentrant {
        // Ensure the drop does not already have a live auction
        require(auctionForDrop[_tokenContract].startTime == 0, "ONLY_ONE_LIVE_AUCTION_PER_DROP");

        // Ensure the funds recipient is specified
        require(_sellerFundsRecipient != address(0), "INVALID_FUNDS_RECIPIENT");

        // Get the auction's storage pointer
        Auction storage auction = auctionForDrop[_tokenContract];

        // Store the associated metadata
        auction.seller = msg.sender;
        auction.minimumRevenue = uint96(_minimumRevenue);
        auction.sellerFundsRecipient = _sellerFundsRecipient;
        auction.startTime = uint32(_startTime);
        auction.endOfBidPhase = uint32(_startTime + _bidPhaseDuration);
        auction.endOfRevealPhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration);
        auction.endOfSettlePhase = uint32(_startTime + _bidPhaseDuration + _revealPhaseDuration + _settlePhaseDuration);

        emit AuctionCreated(_tokenContract, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        PLACE BID
    //////////////////////////////////////////////////////////////*/

    // TODO add UML

    /// @notice Emitted when a bid is placed
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param bidder The address that placed a sealed bid
    /// @param auction The metadata of the auction
    event BidPlaced(address indexed tokenContract, address indexed bidder, Auction auction);

    /// @notice Places a bid in a variable supply auction
    /// @dev Note that the included ether amount must be greater than or equal to the sealed bid
    /// amount. This allows the bidder to obfuscate their true bid amount until the reveal phase.
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _commitmentHash The sha256 hash of the sealed bid amount concatenated with
    /// a salt string, both of which need to be included in the subsequent reveal bid tx
    function placeBid(address _tokenContract, bytes32 _commitmentHash) public payable nonReentrant {
        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure the auction exists
        require(auction.seller != address(0), "AUCTION_DOES_NOT_EXIST");

        // Ensure the auction is still in bid phase
        require(block.timestamp < auction.endOfBidPhase, "BIDS_ONLY_ALLOWED_DURING_BID_PHASE");

        // Ensure the bidder has not placed a bid in auction already
        require(balanceOf[_tokenContract][msg.sender] == 0, "ALREADY_PLACED_BID_IN_AUCTION");

        // Ensure the bid is valid and includes some ether
        require(msg.value > 0 ether, "VALID_BIDS_MUST_INCLUDE_ETHER");

        // Store the full amount of incoming ether for this auction
        auction.totalBalance += uint96(msg.value);
        
        // Store the amount of incoming ether for this bidder
        balanceOf[_tokenContract][msg.sender] = uint96(msg.value);

        // Store the committed / unrevealed bid for this bidder
        bidOf[_tokenContract][msg.sender] = Bid({
            commitmentHash: _commitmentHash,
            revealedBidAmount: 0
        });

        emit BidPlaced(_tokenContract, msg.sender, auction);
    }

    /*//////////////////////////////////////////////////////////////
                        REVEAL BID
    //////////////////////////////////////////////////////////////*/

    // TODO add UML

    /// @notice Emitted when a bid is revealed
    /// @param tokenContract The address of the ERC-721 drop contract
    /// @param bidder The address that placed a sealed bid
    /// @param bidAmount The revealed bid amount
    /// @param auction The metadata of the auction
    event BidRevealed(address indexed tokenContract, address indexed bidder, uint256 indexed bidAmount, Auction auction);

    /// @notice Reveals a previously placed bid
    /// @param _tokenContract The address of the ERC-721 drop contract
    /// @param _bidAmount The true bid amount
    /// @param _salt The string which was used, in combination with the true bid amount,
    /// to generate the commitment hash sent with the original placed bid tx
    function revealBid(address _tokenContract, uint256 _bidAmount, string calldata _salt) public nonReentrant {
        // Get the auction for the specified drop
        Auction storage auction = auctionForDrop[_tokenContract];

        // Ensure auction is in reveal phase
        require(block.timestamp >= auction.endOfBidPhase && block.timestamp < auction.endOfRevealPhase, "REVEALS_ONLY_ALLOWED_DURING_REVEAL_PHASE");

        // Get the bid for the specified bidder
        Bid storage bid = bidOf[_tokenContract][msg.sender];

        // Ensure bidder placed bid in auction
        require(balanceOf[_tokenContract][msg.sender] > 0 ether, "NO_PLACED_BID_FOUND_FOR_ADDRESS");

        // Ensure revealed bid amount is not greater than sent ether
        require(_bidAmount <= balanceOf[_tokenContract][msg.sender], "REVEALED_BID_CANNOT_BE_GREATER_THAN_SENT_ETHER");

        // Ensure revealed bid matches sealed bid
        require(keccak256(abi.encodePacked(_bidAmount, bytes(_salt))) == bid.commitmentHash, "REVEALED_BID_DOES_NOT_MATCH_SEALED_BID");

        // Store the revealed bid amount
        bid.revealedBidAmount = uint96(_bidAmount);

        emit BidRevealed(_tokenContract, msg.sender, _bidAmount, auction);
    }
}
